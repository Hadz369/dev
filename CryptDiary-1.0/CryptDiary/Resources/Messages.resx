<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ErrorEncryptedDataElementNotFound" xml:space="preserve">
    <value>Das "EncryptedData"-Element wurde nicht gefunden.</value>
  </data>
  <data name="ErrorFileCanNotBeWritten" xml:space="preserve">
    <value>Datei kann nicht geschrieben werden.\nWurde ein Arbeitsverzeichnis gewählt?</value>
  </data>
  <data name="ErrorInvalidDateString" xml:space="preserve">
    <value>Das Datum enthält ungültige Zeichen: </value>
  </data>
  <data name="ErrorInvalidFileNameFormat" xml:space="preserve">
    <value>Der Dateiname hat ein ungültiges Format: </value>
  </data>
  <data name="ErrorInvalidKeyLength" xml:space="preserve">
    <value>Die Keylänge muss 128, 192 oder 256 Bit betragen.</value>
  </data>
  <data name="ErrorIterationCountNotParsable" xml:space="preserve">
    <value>Der Iteration-Count konnte nicht aus der Xml-Datei geparsed werden.\n</value>
  </data>
  <data name="ErrorIVNotReadable" xml:space="preserve">
    <value>Der IV konnte nicht aus der Xml-Datei gelesen werden.\n</value>
  </data>
  <data name="ErrorKeySizeNotReadable" xml:space="preserve">
    <value>Die KeySize konnte nicht aus der Xml-Datei gelesen werden.\n</value>
  </data>
  <data name="ErrorNeighborDateNotFound" xml:space="preserve">
    <value>Kein Nachbardatum gefunden.</value>
  </data>
  <data name="ErrorSaltNotReadable" xml:space="preserve">
    <value>Der Salt konnte nicht aus der Xml-Datei gelesen werden.\n</value>
  </data>
  <data name="ErrorWrongDateFormat" xml:space="preserve">
    <value>Das Datum konnte nicht ermittelt werden. Liegt es im falschen Format vor?</value>
  </data>
  <data name="ErrorWrongPassword" xml:space="preserve">
    <value>Falsches Passwort?</value>
  </data>
  <data name="ErrorXmlAttributeDateNotFound" xml:space="preserve">
    <value>Das Attribut \"Date\" wurde nicht gefunden.</value>
  </data>
  <data name="ErrorXmlElementNotFound" xml:space="preserve">
    <value>Das spezifizierte XML-Element wurde nicht gefunden.</value>
  </data>
  <data name="InfoDiaryLocked" xml:space="preserve">
    <value>Tagebuch gesperrt!</value>
  </data>
  <data name="InfoDirectoryNotEmpty" xml:space="preserve">
    <value>Ordner muss leer sein!</value>
  </data>
  <data name="InfoPasswordsNotEqual" xml:space="preserve">
    <value>Die beiden Eingaben für das neue Passwort stimmen nicht überein.</value>
  </data>
  <data name="PromptConfirmNewPassword" xml:space="preserve">
    <value>Bitte das neue Passwort zur Bestätigung erneut eingeben.</value>
  </data>
  <data name="PromptEnterNewPassword" xml:space="preserve">
    <value>Bitte das neue Passwort eingeben.</value>
  </data>
  <data name="PromptEnterOldPassword" xml:space="preserve">
    <value>Bitte das alte Passwort eingeben.</value>
  </data>
  <data name="InfoPasswordIterationsText" xml:space="preserve">
    <value>Um Brute-Force-Angriffe bei der Passwort-Eingabe zu erschweren, wird das eingegebene Passwort mindestens 1000 mal gehashed. Dies dauert lang genug, um wiederholte Passworteingaben sehr stark zu verlangsamen, ist aber schnell genug, um einzelne Passworteingaben nicht unnötig auszubremsen. Versuchen Sie, einen Wert zu finden, der bei einem Benchmark ein Ergebnis zwischen 100 und 300 ms liefert.</value>
  </data>
  <data name="ErrorFileToDeleteDoesNotExist" xml:space="preserve">
    <value>Die zu löschende Datei existiert nicht.</value>
  </data>
  <data name="ErrorDiaryEntryFileNotLoadable" xml:space="preserve">
    <value>Tagebucheintragsdatei konnte nicht geladen werden.</value>
  </data>
  <data name="ErrorEncryptionInfoNotFound" xml:space="preserve">
    <value>Die Xml-Datei enthält keinen Knoten "EncryptionInformation"</value>
  </data>
</root>